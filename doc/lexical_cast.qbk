[library Boost.Lexical_Cast
    [quickbook 1.5]
    [version 1.0]
    [copyright 2000-2005 Kevlin Henney]
    [copyright 2006-2010 Alexander Nasonov]
    [copyright 2011-2024 Antony Polukhin]
    [category String and text processing]
    [category Miscellaneous]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[def __numericcast__  [@boost:libs/numeric/conversion/doc/html/boost_numericconversion/improved_numeric_cast__.html `boost::numeric_cast`]]
[def __proposallong__ [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1973.html Lexical Conversion Library Proposal for TR2, N1973 by Kevlin Henney and Beman Dawes]]
[def __proposalshort__ [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1973.html Lexical Conversion Library Proposal for TR2, N1973]]

[section Motivation]
Sometimes a value must be converted to a literal text form, such as an [c++] `int` represented as a `std::string`, or vice-versa, when a `std::string` is interpreted as an `int`. Such examples are common when converting between data types internal to a program and representation external to a program, such as windows and configuration files.

The standard C and C++ libraries offer a number of facilities for performing such conversions. However, they vary with their ease of use, extensibility, and safety.

For instance, there are a number of limitations with the family of standard C functions typified by `atoi`:

* Conversion is supported in one direction only: from text to internal data type. Converting the other way using the C library requires either the inconvenience and compromised safety of the `sprintf` function, or the loss of portability associated with non-standard functions such as `itoa`.
* The range of types supported is only a subset of the built-in numeric types, namely `int`, `long`, and `double`.
* The range of types cannot be extended in a uniform manner. For instance, conversion from string representation to complex or rational.

The standard C functions typified by `strtol` have the same basic limitations, but offer finer control over the conversion process. However, for the common case such control is often either not required or not used. The `scanf` family of functions offer even greater control, but also lack safety and ease of use.

The standard C++ library offers `stringstream` for the kind of in-core formatting being discussed. It offers a great deal of control over the formatting and conversion of I/O to and from arbitrary types through text. However, for simple conversions direct use of `stringstream` can be either clumsy (with the introduction of extra local variables and the loss of infix-expression convenience) or obscure (where `stringstream` objects are created as temporary objects in an expression). Facets provide a comprehensive concept and facility for controlling textual representation, but their perceived complexity and high entry level requires an extreme degree of involvement for simple conversions, and excludes all but a few programmers.

The `lexical_cast` function template offers a convenient and consistent form for supporting common conversions to and from arbitrary types when they are represented as text. The simplification it offers is in expression-level convenience for such conversions. For more involved conversions, such as where precision or formatting need tighter control than is offered by the default behavior of `lexical_cast`, the conventional `std::stringstream` approach is recommended. Where the conversions are numeric to numeric, __numericcast__ may offer more reasonable behavior than `lexical_cast`.

For a good discussion of the options and issues involved in string-based formatting, including comparison of `stringstream`, `lexical_cast`, and others, see Herb Sutter's article, [@http://www.gotw.ca/publications/mill19.htm The String Formatters of Manor Farm]. Also, take a look at the [link boost_lexical_cast.performance Performance] section.
[endsect]

[section Examples]

[import ../example/args_to_numbers.cpp]

[section Strings to numbers conversion] [lexical_cast_args_example] [endsect]

[import ../example/small_examples.cpp]
[section Numbers to strings conversion] [lexical_cast_log_errno] [endsect]
[section Converting to string without dynamic memory allocation] [lexical_cast_fixed_buffer] [endsect]
[section Converting part of the string] [lexical_cast_substring_conversion] [endsect]

[import ../example/generic_stringize.cpp]
[section Generic programming (Boost.Fusion)] [lexical_cast_stringize] [endsect]

[import ../example/variant_to_long_double.cpp]
[section Generic programming (Boost.Variant)] [lexical_cast_variant_to_long_double] [endsect]

[endsect]

[section Synopsis]
Library features defined in [@boost:boost/lexical_cast.hpp boost/lexical_cast.hpp]:
``
    namespace boost
    {
        class bad_lexical_cast;
        
        template<typename Target, typename Source>
          Target lexical_cast(const Source& arg);

        template <typename Target>
          Target lexical_cast(const AnyCharacterType* chars, std::size_t count);

        namespace conversion
        {
            template<typename Target, typename Source>
                bool try_lexical_convert(const Source& arg, Target& result);

            template <typename AnyCharacterType, typename Target>
                bool try_lexical_convert(const AnyCharacterType* chars, std::size_t count, Target& result);

        } // namespace conversion
    } // namespace boost
``

[section lexical_cast]
``
    template<typename Target, typename Source>
      Target lexical_cast(const Source& arg);
``
Returns the result of streaming arg into a standard library string-based stream and then out as a Target object. Where Target is either `std::string` or `std::wstring`, stream extraction takes the whole content of the string, including spaces, rather than relying on the default `operator>>` behavior. If the conversion is unsuccessful, a `bad_lexical_cast` exception is thrown.

``
    template <typename Target>
      Target lexical_cast(const AnyCharacterType* chars, std::size_t count);
``
Takes an array of `count` characters as input parameter and streams them out as a Target object. If the conversion is unsuccessful, a `bad_lexical_cast` exception is thrown. This call may be useful for processing nonzero terminated array of characters or processing just some part of character array.

The requirements on the argument and result types for both functions are:

* Source is OutputStreamable, meaning that an `operator<<` is defined that takes a `std::ostream` or `std::wostream` object on the left hand side and an instance of the argument type on the right.
* Target is InputStreamable, meaning that an `operator>>` is defined that takes a `std::istream` or `std::wistream` object on the left hand side and an instance of the result type on the right.
* Target is CopyConstructible [20.1.3].
* Target is DefaultConstructible, meaning that it is possible to default-initialize an object of that type [8.5, 20.1.4].

The character type of the underlying stream is assumed to be `char` unless either the `Source` or the `Target` requires wide-character streaming, in which case the underlying stream uses `wchar_t`. Following types also can use `char16_t` or `char32_t` for wide-character streaming:

* Single character: `char16_t`, `char32_t`
* Arrays of characters: `char16_t *`, `char32_t *`, `const char16_t *`, `const char32_t *`
* Strings: `std::basic_string`, `boost::containers::basic_string`
* `boost::iterator_range<WideCharPtr>`, where `WideCharPtr` is a pointer to wide-character or pointer to const wide-character
* `boost::array<CharT, N>` and `std::array<CharT, N>`, `boost::array<const CharT, N>` and `std::array<const CharT, N>` 

[important Many compilers and runtime libraries fail to make conversions using new Unicode characters. Make sure that the following code compiles and outputs nonzero values, before using new types:
``
    std::cout
        << boost::lexical_cast<std::u32string>(1.0).size()
        << "  "
        << boost::lexical_cast<std::u16string>(1.0).size();
``
]

Where a higher degree of control is required over conversions, `std::stringstream` and `std::wstringstream` offer a more appropriate path. Where non-stream-based conversions are required, `lexical_cast` is the wrong tool for the job and is not special-cased for such scenarios.
[endsect]

[section bad_lexical_cast]
``
    class bad_lexical_cast : public std::bad_cast
    {
    public:
        ... // same member function interface as std::exception
    };
``
Exception used to indicate runtime lexical_cast failure.
[endsect]

[section try_lexical_convert]
`boost::lexical_cast` remains the main interface for lexical conversions. It must be used by default in most cases. However
some developers wish to make their own conversion functions, reusing all the optimizations of the `boost::lexical_cast`.
That's where the `boost::conversion::try_lexical_convert` function steps in.

`try_lexical_convert` returns `true` if conversion succeeded, otherwise returns `false`. If conversion
failed and `false` was returned, state of `result` output variable is undefined.

Actually, `boost::lexical_cast` is implemented using `try_lexical_convert`:
``
    template <typename Target, typename Source>
    inline Target lexical_cast(const Source &arg)
    {
        Target result;

        if (!conversion::try_lexical_convert(arg, result))
            throw bad_lexical_cast();

        return result;
    }
``

`try_lexical_convert` relaxes the CopyConstructible and DefaultConstructible requirements for `Target` type.
Following requirements for `Target` and `Source` remain:

* Source must be OutputStreamable, meaning that an `operator<<` is defined that takes a `std::ostream` or `std::wostream` object on the left hand side and an instance of the argument type on the right.
* Target must be InputStreamable, meaning that an `operator>>` is defined that takes a `std::istream` or `std::wistream` object on the left hand side and an instance of the result type on the right.

[endsect]


[endsect]

[section Frequently Asked Questions]

* [*Question:]    Why does `lexical_cast<int8_t>("127")` throw `bad_lexical_cast`?
  * [*Answer:]      The type `int8_t` is a `typedef` to `char` or `signed char`. Lexical conversion to these types is simply reading a byte from source but since the source has more than one byte, the exception is thrown.
Please use other integer types such as `int` or `short int`. If bounds checking is important, you can also
call __numericcast__:
`numeric_cast<int8_t>(lexical_cast<int>("127"));`

[pre
]

* [*Question:]    Why does `lexical_cast<unsigned char>("127")` throw `bad_lexical_cast`?
  * [*Answer:]      Lexical conversion to any char type is simply reading a byte from source. But since the source has more than one byte, the exception is thrown.
Please use other integer types such as `int` or `short int`. If bounds checking is important, you can also
call __numericcast__:
`numeric_cast<unsigned char>(lexical_cast<int>("127"));`

[pre
]

* [*Question:]    What does `lexical_cast<std::string>` of an `int8_t` or `uint8_t` not do what I expect?
  * [*Answer:]      As above, note that int8_t and uint8_t are actually chars and are formatted as such. To avoid
this, cast to an integer type first: `lexical_cast<std::string>(static_cast<int>(n));`

[pre
]

* [*Question:]    The implementation always resets the `ios_base::skipws` flag of an underlying stream object.
It breaks my `operator>>` that works only in presence of this flag. Can you remove code that resets the flag?
  * [*Answer:]      May be in a future version. There is no requirement in
__proposallong__ to reset the flag but
remember that __proposalshort__ is not yet accepted by the committee. By the way, it's a great opportunity to
make your `operator>>` more general.
Read a good C++ book, study `std::sentry` and [@boost:libs/io/doc/ios_state.html `ios_state_saver`].

[pre
]

* [*Question:]    Why `std::cout << boost::lexical_cast<unsigned int>("-1");` does not throw, but outputs 4294967295?
  * [*Answer:]      `boost::lexical_cast` has the behavior of `std::stringstream`, which uses `num_get` functions of
`std::locale` to convert numbers. If we look at the Programming languages â€” C++, we'll see, that `num_get` uses
the rules of `scanf` for conversions. And in the C99 standard for unsigned input value minus sign is optional, so
if a negative number is read, no errors will arise and the result will be the two's complement.

[pre
]

* [*Question:]    Why `boost::lexical_cast<int>(L'A');` outputs 65 and `boost::lexical_cast<wchar_t>(L"65");` does not throw?
  * [*Answer:]      If you are using an old version of Visual Studio or compile code with /Zc:wchar_t- flag,
`boost::lexical_cast` sees single `wchar_t` character as `unsigned short`. It is not a `boost::lexical_cast` mistake, but a
limitation of compiler options that you use.

[pre
]

* [*Question:]    Why `boost::lexical_cast<double>("-1.#IND");` throws `boost::bad_lexical_cast`?
  * [*Answer:]      `"-1.#IND"` is a compiler extension, that violates standard. You shall input `"-nan"`, `"nan"`, `"inf"`
, `"-inf"` (case insensitive) strings to get NaN and Inf values. `boost::lexical_cast<string>` outputs `"-nan"`, `"nan"`,
`"inf"`, `"-inf"` strings, when has NaN or Inf input values.

[pre
]

* [*Question:]    What is the fastest way to convert a non zero terminated string or a substring using `boost::lexical_cast`?
  * [*Answer:]      Use `boost::iterator_range` for conversion or `lexical_cast` overload with two parameters. For example, if you whant to convert to `int` two characters from a string `str`, you shall write `lexical_cast<int>(make_iterator_range(str.data(), str.data() + 2));` or `lexical_cast<int>(str.data(), 2);`.

[endsect]

[section Changes]

* [*boost 1.84.0 :]

    * Dropped support of C++98 and C++03.

* [*boost 1.56.0 :]

    * Added `boost::conversion::try_lexical_convert` functions.

* [*boost 1.54.0 :]

    * Fix some issues with `boost::int128_type` and `boost::uint128_type` conversions. Notify user at compile time 
      if the `std::numeric_limits` are not specialized for 128bit types and `boost::lexical_cast` can not make conversions.

* [*boost 1.54.0 :]

    * Added code to convert `boost::int128_type` and `boost::uint128_type` types (requires GCC 4.7 or higher).
    * Conversions to pointers will now fail to compile, instead of throwing at runtime.
    * Restored ability to get pointers to `lexical_cast` function (was broken in 1.53.0).

* [*boost 1.53.0 :]

    * Much better input and output streams detection for user defined types.

* [*boost 1.52.0 :]

    * Restored compilation on MSVC-2003 (was broken in 1.51.0).
    * Added `lexical_cast(const CharType* chars, std::size_t count)` function overload.
    
* [*boost 1.51.0 :]

    * Better performance, less memory usage for `boost::array<character_type, N>` and `std::array<character_type, N>` conversions.

* [*boost 1.50.0 :]

    * `boost::bad_lexical_cast` exception is now globaly visible and can be catched even if code is compiled with -fvisibility=hidden.
    * Now it is possible to compile library with disabled exceptions.
    * Better performance, less memory usage and bugfixes for `boost::iterator_range<character_type*>` conversions.

* [*boost 1.49.0 :]

    * Restored work with typedefed wchar_t (compilation flag /Zc:wchar_t- for Visual Studio).
    * Better performance and less memory usage for `boost::container::basic_string` conversions.

* [*boost 1.48.0 :]

    * Added code to work with Inf and NaN on any platform.
    * Better performance and less memory usage for conversions to float type (and to double type, if `sizeof(double) < sizeof(long double)`).

* [*boost 1.47.0 :]

    * Optimizations for "C" and other locales without number grouping.
    * Better performance and less memory usage for unsigned char and signed char conversions.
    * Better performance and less memory usage for conversions to arithmetic types.
    * Better performance and less memory usage for conversions from arithmetic type to arithmetic type.
    * Directly construct Target from Source on some conversions (like conversions from string to string, from char array to string, from char to char and others).

* [*boost 1.34.0 :]

    * Better performance for many combinations of Source and Target types. For more details refer to Alexander Nasonovs article [@http://accu.org/index.php/journals/1375 Fine Tuning for lexical_cast, Overload #74, August 2006] [@http://www.accu.org/var/uploads/journals/overload74.pdf (PDF)].

* [*boost 1.33.0 :]

    * Call-by-const reference for the parameters. This requires partial specialization of class templates, so it doesn't work for MSVC 6, and it uses the original pass by value there.
    * The MSVC 6 support is deprecated, and will be removed in a future Boost version.

* [*Earlier :]

    * The previous version of lexical_cast used the default stream precision for reading and writing floating-point numbers. For numerics that have a corresponding specialization of `std::numeric_limits`, the current version now chooses a precision to match.
    * The previous version of lexical_cast did not support conversion to or from any wide-character-based types. For compilers with full language and library support for wide characters, `lexical_cast` now supports conversions from `wchar_t`, `wchar_t *`, and `std::wstring` and to `wchar_t` and `std::wstring`.
    * The previous version of `lexical_cast` assumed that the conventional stream extractor operators were sufficient for reading values. However, string I/O is asymmetric, with the result that spaces play the role of I/O separators rather than string content. The current version fixes this error for `std::string` and, where supported, `std::wstring`: `lexical_cast<std::string>("Hello, World")` succeeds instead of failing with a `bad_lexical_cast` exception.
    * The previous version of `lexical_cast` allowed unsafe and meaningless conversions to pointers. The current version now throws a `bad_lexical_cast` for conversions to pointers: `lexical_cast<char *>("Goodbye, World")` now throws an exception instead of causing undefined behavior.

[endsect]

[section Performance]

In most cases `boost::lexical_cast` is faster than `scanf`, `printf`, `std::stringstream`. For more detailed info you can look at the tables below.

[section Tests description]
All the tests measure execution speed in milliseconds for 10000 iterations of the following code blocks:
[table:legend Tests source code
[[Test name] [Code]]
[[lexical_cast]
  [``
            _out = boost::lexical_cast<OUTTYPE>(_in);
  ``]
  ]
[[std::stringstream with construction]
  [``
            std::stringstream ss;
            ss << _in;
            if (ss.fail()) throw std::logic_error(descr);
            ss >> _out;
            if (ss.fail()) throw std::logic_error(descr);
  ``]
  ]
[[std::stringstream without construction]
  [``
            ss << _in; // ss is an instance of std::stringstream
            if (ss.fail()) throw std::logic_error(descr);
            ss >> _out;
            if (ss.fail()) throw std::logic_error(descr);
            /* reseting std::stringstream to use it again */
            ss.str(std::string());
            ss.clear();
  ``]
  ]
[[scanf/printf]
  [``
            typename OUTTYPE::value_type buffer[500];
            sprintf( (char*)buffer, conv, _in);
            _out = buffer;
  ``]
  ]
]
Fastest results are highlitened with "!!! *x* !!!".
Do not use this results to compare compilers, because tests were taken on different hardware.

[endsect]

[/ BEGIN of section, generated by performance measuring program ]



[section GNU C++ version 9.4.0]
[table:id Performance Table ( GNU C++ version 9.4.0)
[[From->To] [lexical_cast] [std::stringstream with construction] [std::stringstream without construction][scanf/printf]]
  [[ string->char ][ !!! *1* !!! ][ 57 ][ 5 ][ 7 ]]
  [[ string->signed char ][ !!! *1* !!! ][ 56 ][ 5 ][ 8 ]]
  [[ string->unsigned char ][ !!! *1* !!! ][ 60 ][ 5 ][ 8 ]]
  [[ string->int ][ !!! *4* !!! ][ 63 ][ 12 ][ 18 ]]
  [[ string->short ][ !!! *4* !!! ][ 67 ][ 12 ][ 12 ]]
  [[ string->long int ][ !!! *4* !!! ][ 66 ][ 12 ][ 12 ]]
  [[ string->long long ][ !!! *4* !!! ][ 68 ][ 12 ][ 12 ]]
  [[ string->unsigned int ][ !!! *4* !!! ][ 66 ][ 11 ][ 13 ]]
  [[ string->unsigned short ][ !!! *4* !!! ][ 64 ][ 11 ][ 12 ]]
  [[ string->unsigned long int ][ !!! *3* !!! ][ 61 ][ 11 ][ 11 ]]
  [[ string->unsigned long long ][ !!! *4* !!! ][ 64 ][ 11 ][ 13 ]]
  [[ string->float ][ 56 ][ 162 ][ 89 ][ !!! *23* !!! ]]
  [[ string->double ][ 57 ][ 89 ][ 32 ][ !!! *28* !!! ]]
  [[ string->long double ][ 137 ][ 233 ][ 91 ][ !!! *63* !!! ]]
  [[ string->array<char, 50> ][ !!! *1* !!! ][ 157 ][ 27 ][ 20 ]]
  [[ string->string ][ !!! *2* !!! ][ 157 ][ 28 ][ --- ]]
  [[ string->container::string ][ !!! *1* !!! ][ 162 ][ 29 ][ --- ]]
  [[ string->char ][ !!! *3* !!! ][ 147 ][ 26 ][ 19 ]]
  [[ string->signed char ][ !!! *3* !!! ][ 151 ][ 25 ][ 25 ]]
  [[ string->unsigned char ][ !!! *3* !!! ][ 160 ][ 27 ][ 26 ]]
  [[ int->string ][ !!! *11* !!! ][ 158 ][ 39 ][ 25 ]]
  [[ short->string ][ !!! *11* !!! ][ 161 ][ 34 ][ 27 ]]
  [[ long int->string ][ !!! *11* !!! ][ 158 ][ 36 ][ 26 ]]
  [[ long long->string ][ !!! *11* !!! ][ 179 ][ 34 ][ 27 ]]
  [[ unsigned int->string ][ !!! *11* !!! ][ 161 ][ 37 ][ 26 ]]
  [[ unsigned short->string ][ !!! *10* !!! ][ 168 ][ 37 ][ 26 ]]
  [[ unsigned long int->string ][ !!! *11* !!! ][ 164 ][ 38 ][ 26 ]]
  [[ unsigned long long->string ][ !!! *11* !!! ][ 164 ][ 34 ][ 26 ]]
  [[ float->string ][ 66 ][ 269 ][ 120 ][ !!! *59* !!! ]]
  [[ double->string ][ 83 ][ 308 ][ 128 ][ !!! *59* !!! ]]
  [[ long double->string ][ 117 ][ 280 ][ 138 ][ !!! *67* !!! ]]
  [[ char*->char ][ !!! *3* !!! ][ 131 ][ 14 ][ 20 ]]
  [[ char*->signed char ][ !!! *3* !!! ][ 132 ][ 16 ][ 24 ]]
  [[ char*->unsigned char ][ !!! *3* !!! ][ 140 ][ 15 ][ 24 ]]
  [[ char*->int ][ !!! *11* !!! ][ 158 ][ 33 ][ 34 ]]
  [[ char*->short ][ !!! *11* !!! ][ 158 ][ 30 ][ 35 ]]
  [[ char*->long int ][ !!! *11* !!! ][ 174 ][ 30 ][ 34 ]]
  [[ char*->long long ][ !!! *11* !!! ][ 158 ][ 30 ][ 34 ]]
  [[ char*->unsigned int ][ !!! *11* !!! ][ 156 ][ 31 ][ 34 ]]
  [[ char*->unsigned short ][ !!! *11* !!! ][ 163 ][ 29 ][ 34 ]]
  [[ char*->unsigned long int ][ !!! *11* !!! ][ 150 ][ 32 ][ 33 ]]
  [[ char*->unsigned long long ][ !!! *11* !!! ][ 164 ][ 32 ][ 35 ]]
  [[ char*->float ][ 134 ][ 223 ][ 94 ][ !!! *61* !!! ]]
  [[ char*->double ][ 137 ][ 227 ][ 78 ][ !!! *62* !!! ]]
  [[ char*->long double ][ 137 ][ 220 ][ 84 ][ !!! *66* !!! ]]
  [[ char*->array<char, 50> ][ !!! *1* !!! ][ 150 ][ 31 ][ 20 ]]
  [[ char*->string ][ !!! *3* !!! ][ 169 ][ 30 ][ --- ]]
  [[ char*->container::string ][ !!! *2* !!! ][ 157 ][ 32 ][ --- ]]
  [[ unsigned char*->char ][ !!! *3* !!! ][ 136 ][ 16 ][ 18 ]]
  [[ unsigned char*->signed char ][ !!! *2* !!! ][ 133 ][ 14 ][ 21 ]]
  [[ unsigned char*->unsigned char ][ !!! *4* !!! ][ 141 ][ 15 ][ 21 ]]
  [[ unsigned char*->int ][ !!! *10* !!! ][ 155 ][ 33 ][ 29 ]]
  [[ unsigned char*->short ][ !!! *11* !!! ][ 149 ][ 31 ][ 30 ]]
  [[ unsigned char*->long int ][ !!! *10* !!! ][ 100 ][ 12 ][ 12 ]]
  [[ unsigned char*->long long ][ !!! *4* !!! ][ 60 ][ 12 ][ 12 ]]
  [[ unsigned char*->unsigned int ][ !!! *4* !!! ][ 61 ][ 11 ][ 12 ]]
  [[ unsigned char*->unsigned short ][ !!! *4* !!! ][ 58 ][ 11 ][ 12 ]]
  [[ unsigned char*->unsigned long int ][ !!! *4* !!! ][ 61 ][ 15 ][ 12 ]]
  [[ unsigned char*->unsigned long long ][ !!! *4* !!! ][ 60 ][ 12 ][ 12 ]]
  [[ unsigned char*->float ][ 57 ][ 88 ][ 38 ][ !!! *23* !!! ]]
  [[ unsigned char*->double ][ 53 ][ 93 ][ 34 ][ !!! *23* !!! ]]
  [[ unsigned char*->long double ][ 54 ][ 85 ][ 35 ][ !!! *30* !!! ]]
  [[ unsigned char*->array<char, 50> ][ !!! *<1* !!! ][ 68 ][ 12 ][ 8 ]]
  [[ unsigned char*->string ][ !!! *2* !!! ][ 65 ][ 13 ][ --- ]]
  [[ unsigned char*->container::string ][ !!! *1* !!! ][ 63 ][ 12 ][ --- ]]
  [[ signed char*->char ][ !!! *1* !!! ][ 54 ][ 6 ][ 7 ]]
  [[ signed char*->signed char ][ !!! *<1* !!! ][ 59 ][ 6 ][ 8 ]]
  [[ signed char*->unsigned char ][ !!! *1* !!! ][ 56 ][ 6 ][ 8 ]]
  [[ signed char*->int ][ !!! *4* !!! ][ 64 ][ 12 ][ 12 ]]
  [[ signed char*->short ][ !!! *4* !!! ][ 68 ][ 12 ][ 12 ]]
  [[ signed char*->long int ][ !!! *4* !!! ][ 66 ][ 13 ][ 12 ]]
  [[ signed char*->long long ][ !!! *4* !!! ][ 68 ][ 13 ][ 12 ]]
  [[ signed char*->unsigned int ][ !!! *4* !!! ][ 62 ][ 11 ][ 12 ]]
  [[ signed char*->unsigned short ][ !!! *4* !!! ][ 69 ][ 11 ][ 12 ]]
  [[ signed char*->unsigned long int ][ !!! *4* !!! ][ 60 ][ 13 ][ 12 ]]
  [[ signed char*->unsigned long long ][ !!! *4* !!! ][ 62 ][ 12 ][ 12 ]]
  [[ signed char*->float ][ 52 ][ 90 ][ 35 ][ !!! *23* !!! ]]
  [[ signed char*->double ][ 51 ][ 94 ][ 32 ][ !!! *23* !!! ]]
  [[ signed char*->long double ][ 58 ][ 90 ][ 34 ][ !!! *25* !!! ]]
  [[ signed char*->array<char, 50> ][ !!! *<1* !!! ][ 117 ][ 30 ][ 21 ]]
  [[ signed char*->string ][ !!! *5* !!! ][ 166 ][ 33 ][ --- ]]
  [[ signed char*->container::string ][ !!! *2* !!! ][ 148 ][ 30 ][ --- ]]
  [[ iterator_range<char*>->char ][ !!! *1* !!! ][ 139 ][ 14 ][ 17 ]]
  [[ iterator_range<char*>->signed char ][ !!! *<1* !!! ][ 146 ][ 13 ][ 21 ]]
  [[ iterator_range<char*>->unsigned char ][ !!! *1* !!! ][ 149 ][ 13 ][ 21 ]]
  [[ iterator_range<char*>->int ][ !!! *10* !!! ][ 168 ][ 42 ][ 30 ]]
  [[ iterator_range<char*>->short ][ !!! *10* !!! ][ 172 ][ 42 ][ 30 ]]
  [[ iterator_range<char*>->long int ][ !!! *9* !!! ][ 169 ][ 38 ][ 29 ]]
  [[ iterator_range<char*>->long long ][ !!! *10* !!! ][ 164 ][ 38 ][ 29 ]]
  [[ iterator_range<char*>->unsigned int ][ !!! *9* !!! ][ 163 ][ 35 ][ 30 ]]
  [[ iterator_range<char*>->unsigned short ][ !!! *10* !!! ][ 163 ][ 36 ][ 29 ]]
  [[ iterator_range<char*>->unsigned long int ][ !!! *10* !!! ][ 166 ][ 37 ][ 30 ]]
  [[ iterator_range<char*>->unsigned long long ][ !!! *10* !!! ][ 163 ][ 37 ][ 30 ]]
  [[ iterator_range<char*>->float ][ 134 ][ 252 ][ 103 ][ !!! *57* !!! ]]
  [[ iterator_range<char*>->double ][ 134 ][ 250 ][ 100 ][ !!! *57* !!! ]]
  [[ iterator_range<char*>->long double ][ 141 ][ 242 ][ 121 ][ !!! *67* !!! ]]
  [[ iterator_range<char*>->array<char, 50> ][ !!! *1* !!! ][ 170 ][ 45 ][ 20 ]]
  [[ iterator_range<char*>->string ][ !!! *3* !!! ][ 180 ][ 51 ][ --- ]]
  [[ iterator_range<char*>->container::string ][ !!! *2* !!! ][ 195 ][ 54 ][ --- ]]
  [[ std::string_view->char ][ 61 ][ 141 ][ 14 ][ !!! *13* !!! ]]
  [[ std::string_view->signed char ][ 53 ][ 137 ][ !!! *16* !!! ][ 17 ]]
  [[ std::string_view->unsigned char ][ 57 ][ 153 ][ !!! *13* !!! ][ 17 ]]
  [[ std::string_view->int ][ 66 ][ 170 ][ 33 ][ !!! *26* !!! ]]
  [[ std::string_view->short ][ 69 ][ 164 ][ 29 ][ !!! *26* !!! ]]
  [[ std::string_view->long int ][ 65 ][ 159 ][ 29 ][ !!! *25* !!! ]]
  [[ std::string_view->long long ][ 72 ][ 150 ][ 29 ][ !!! *25* !!! ]]
  [[ std::string_view->unsigned int ][ 67 ][ 150 ][ 26 ][ !!! *25* !!! ]]
  [[ std::string_view->unsigned short ][ 64 ][ 158 ][ 26 ][ !!! *25* !!! ]]
  [[ std::string_view->unsigned long int ][ 70 ][ 158 ][ 27 ][ !!! *26* !!! ]]
  [[ std::string_view->unsigned long long ][ 72 ][ 154 ][ 28 ][ !!! *26* !!! ]]
  [[ std::string_view->float ][ 219 ][ 231 ][ 96 ][ !!! *53* !!! ]]
  [[ std::string_view->double ][ 219 ][ 221 ][ 87 ][ !!! *54* !!! ]]
  [[ std::string_view->long double ][ 205 ][ 220 ][ 84 ][ !!! *58* !!! ]]
  [[ std::string_view->array<char, 50> ][ 61 ][ 154 ][ 26 ][ !!! *21* !!! ]]
  [[ std::string_view->string ][ 58 ][ 154 ][ !!! *28* !!! ][ --- ]]
  [[ std::string_view->container::string ][ 57 ][ 155 ][ !!! *29* !!! ][ --- ]]
  [[ array<char, 50>->char ][ !!! *<1* !!! ][ 116 ][ 10 ][ 5 ]]
  [[ array<char, 50>->signed char ][ !!! *<1* !!! ][ 59 ][ 6 ][ 7 ]]
  [[ array<char, 50>->unsigned char ][ !!! *<1* !!! ][ 52 ][ 6 ][ 8 ]]
  [[ array<char, 50>->int ][ !!! *8* !!! ][ 155 ][ 31 ][ 20 ]]
  [[ array<char, 50>->short ][ !!! *3* !!! ][ 61 ][ 12 ][ 10 ]]
  [[ array<char, 50>->long int ][ !!! *3* !!! ][ 64 ][ 12 ][ 10 ]]
  [[ array<char, 50>->long long ][ !!! *3* !!! ][ 66 ][ 12 ][ 10 ]]
  [[ array<char, 50>->unsigned int ][ !!! *3* !!! ][ 63 ][ 11 ][ 10 ]]
  [[ array<char, 50>->unsigned short ][ !!! *3* !!! ][ 62 ][ 11 ][ 10 ]]
  [[ array<char, 50>->unsigned long int ][ !!! *3* !!! ][ 62 ][ 12 ][ 10 ]]
  [[ array<char, 50>->unsigned long long ][ !!! *3* !!! ][ 61 ][ 12 ][ 10 ]]
  [[ array<char, 50>->float ][ 55 ][ 89 ][ 35 ][ !!! *21* !!! ]]
  [[ array<char, 50>->double ][ 54 ][ 88 ][ 34 ][ !!! *21* !!! ]]
  [[ array<char, 50>->long double ][ 54 ][ 89 ][ 32 ][ !!! *23* !!! ]]
  [[ array<char, 50>->array<char, 50> ][ !!! *1* !!! ][ 61 ][ 12 ][ 8 ]]
  [[ array<char, 50>->string ][ !!! *2* !!! ][ 65 ][ 12 ][ --- ]]
  [[ array<char, 50>->container::string ][ !!! *1* !!! ][ 64 ][ 13 ][ --- ]]
  [[ int->int ][ !!! *<1* !!! ][ 67 ][ 15 ][ --- ]]
  [[ float->double ][ !!! *<1* !!! ][ 138 ][ 78 ][ --- ]]
  [[ char->signed char ][ !!! *<1* !!! ][ 53 ][ 5 ][ --- ]]
]
[endsect]

[section Clang version 15.0.7 ]
[table:id Performance Table ( Clang version 15.0.7 )
[[From->To] [lexical_cast] [std::stringstream with construction] [std::stringstream without construction][scanf/printf]]
  [[ string->char ][ !!! *<1* !!! ][ 62 ][ 5 ][ 6 ]]
  [[ string->signed char ][ !!! *<1* !!! ][ 57 ][ 5 ][ 7 ]]
  [[ string->unsigned char ][ !!! *<1* !!! ][ 53 ][ 5 ][ 7 ]]
  [[ string->int ][ !!! *3* !!! ][ 58 ][ 12 ][ 11 ]]
  [[ string->short ][ !!! *3* !!! ][ 62 ][ 12 ][ 11 ]]
  [[ string->long int ][ !!! *4* !!! ][ 56 ][ 13 ][ 11 ]]
  [[ string->long long ][ !!! *3* !!! ][ 55 ][ 11 ][ 11 ]]
  [[ string->unsigned int ][ !!! *4* !!! ][ 53 ][ 10 ][ 11 ]]
  [[ string->unsigned short ][ !!! *3* !!! ][ 54 ][ 10 ][ 11 ]]
  [[ string->unsigned long int ][ !!! *3* !!! ][ 58 ][ 11 ][ 11 ]]
  [[ string->unsigned long long ][ !!! *3* !!! ][ 59 ][ 11 ][ 11 ]]
  [[ string->float ][ 60 ][ 81 ][ 33 ][ !!! *23* !!! ]]
  [[ string->double ][ 53 ][ 83 ][ 31 ][ !!! *22* !!! ]]
  [[ string->long double ][ 50 ][ 85 ][ 32 ][ !!! *26* !!! ]]
  [[ string->array<char, 50> ][ !!! *<1* !!! ][ 56 ][ 10 ][ 9 ]]
  [[ string->string ][ !!! *1* !!! ][ 60 ][ 12 ][ --- ]]
  [[ string->container::string ][ !!! *1* !!! ][ 58 ][ 15 ][ --- ]]
  [[ string->char ][ 1 ][ 54 ][ 9 ][ !!! *1* !!! ]]
  [[ string->signed char ][ !!! *1* !!! ][ 52 ][ 9 ][ 10 ]]
  [[ string->unsigned char ][ !!! *1* !!! ][ 53 ][ 9 ][ 10 ]]
  [[ int->string ][ !!! *5* !!! ][ 60 ][ 13 ][ 10 ]]
  [[ short->string ][ !!! *4* !!! ][ 119 ][ 32 ][ 25 ]]
  [[ long int->string ][ 11 ][ 80 ][ 12 ][ !!! *10* !!! ]]
  [[ long long->string ][ !!! *4* !!! ][ 57 ][ 12 ][ 10 ]]
  [[ unsigned int->string ][ !!! *4* !!! ][ 58 ][ 12 ][ 11 ]]
  [[ unsigned short->string ][ !!! *5* !!! ][ 58 ][ 12 ][ 10 ]]
  [[ unsigned long int->string ][ !!! *4* !!! ][ 63 ][ 13 ][ 11 ]]
  [[ unsigned long long->string ][ !!! *4* !!! ][ 56 ][ 13 ][ 10 ]]
  [[ float->string ][ 30 ][ 97 ][ 43 ][ !!! *23* !!! ]]
  [[ double->string ][ 33 ][ 96 ][ 43 ][ !!! *24* !!! ]]
  [[ long double->string ][ 44 ][ 107 ][ 53 ][ !!! *27* !!! ]]
  [[ char*->char ][ !!! *<1* !!! ][ 47 ][ 5 ][ 6 ]]
  [[ char*->signed char ][ !!! *<1* !!! ][ 47 ][ 5 ][ 7 ]]
  [[ char*->unsigned char ][ !!! *<1* !!! ][ 47 ][ 5 ][ 7 ]]
  [[ char*->int ][ !!! *3* !!! ][ 57 ][ 12 ][ 11 ]]
  [[ char*->short ][ !!! *3* !!! ][ 57 ][ 11 ][ 11 ]]
  [[ char*->long int ][ !!! *3* !!! ][ 56 ][ 11 ][ 11 ]]
  [[ char*->long long ][ !!! *3* !!! ][ 55 ][ 11 ][ 11 ]]
  [[ char*->unsigned int ][ !!! *3* !!! ][ 53 ][ 10 ][ 11 ]]
  [[ char*->unsigned short ][ !!! *3* !!! ][ 54 ][ 10 ][ 11 ]]
  [[ char*->unsigned long int ][ !!! *3* !!! ][ 55 ][ 11 ][ 11 ]]
  [[ char*->unsigned long long ][ !!! *3* !!! ][ 56 ][ 11 ][ 11 ]]
  [[ char*->float ][ 48 ][ 82 ][ 34 ][ !!! *22* !!! ]]
  [[ char*->double ][ 46 ][ 76 ][ 30 ][ !!! *22* !!! ]]
  [[ char*->long double ][ 49 ][ 77 ][ 34 ][ !!! *25* !!! ]]
  [[ char*->array<char, 50> ][ !!! *<1* !!! ][ 55 ][ 10 ][ 9 ]]
  [[ char*->string ][ !!! *1* !!! ][ 57 ][ 13 ][ --- ]]
  [[ char*->container::string ][ !!! *1* !!! ][ 60 ][ 15 ][ --- ]]
  [[ unsigned char*->char ][ !!! *<1* !!! ][ 54 ][ 5 ][ 6 ]]
  [[ unsigned char*->signed char ][ !!! *<1* !!! ][ 58 ][ 5 ][ 7 ]]
  [[ unsigned char*->unsigned char ][ !!! *<1* !!! ][ 48 ][ 5 ][ 7 ]]
  [[ unsigned char*->int ][ !!! *3* !!! ][ 57 ][ 12 ][ 11 ]]
  [[ unsigned char*->short ][ !!! *3* !!! ][ 59 ][ 11 ][ 11 ]]
  [[ unsigned char*->long int ][ !!! *5* !!! ][ 55 ][ 11 ][ 11 ]]
  [[ unsigned char*->long long ][ !!! *3* !!! ][ 55 ][ 11 ][ 13 ]]
  [[ unsigned char*->unsigned int ][ !!! *3* !!! ][ 56 ][ 10 ][ 11 ]]
  [[ unsigned char*->unsigned short ][ !!! *3* !!! ][ 56 ][ 11 ][ 11 ]]
  [[ unsigned char*->unsigned long int ][ !!! *3* !!! ][ 55 ][ 11 ][ 11 ]]
  [[ unsigned char*->unsigned long long ][ !!! *3* !!! ][ 55 ][ 11 ][ 11 ]]
  [[ unsigned char*->float ][ 50 ][ 79 ][ 33 ][ !!! *22* !!! ]]
  [[ unsigned char*->double ][ 47 ][ 77 ][ 30 ][ !!! *26* !!! ]]
  [[ unsigned char*->long double ][ 65 ][ 81 ][ 31 ][ !!! *24* !!! ]]
  [[ unsigned char*->array<char, 50> ][ !!! *<1* !!! ][ 54 ][ 11 ][ 9 ]]
  [[ unsigned char*->string ][ !!! *1* !!! ][ 58 ][ 12 ][ --- ]]
  [[ unsigned char*->container::string ][ !!! *1* !!! ][ 61 ][ 15 ][ --- ]]
  [[ signed char*->char ][ !!! *<1* !!! ][ 52 ][ 5 ][ 6 ]]
  [[ signed char*->signed char ][ !!! *<1* !!! ][ 49 ][ 6 ][ 7 ]]
  [[ signed char*->unsigned char ][ !!! *<1* !!! ][ 50 ][ 6 ][ 7 ]]
  [[ signed char*->int ][ !!! *3* !!! ][ 60 ][ 12 ][ 11 ]]
  [[ signed char*->short ][ !!! *3* !!! ][ 56 ][ 11 ][ 11 ]]
  [[ signed char*->long int ][ !!! *3* !!! ][ 57 ][ 11 ][ 11 ]]
  [[ signed char*->long long ][ !!! *3* !!! ][ 116 ][ 28 ][ 27 ]]
  [[ signed char*->unsigned int ][ !!! *9* !!! ][ 74 ][ 10 ][ 13 ]]
  [[ signed char*->unsigned short ][ !!! *3* !!! ][ 53 ][ 10 ][ 11 ]]
  [[ signed char*->unsigned long int ][ !!! *3* !!! ][ 56 ][ 11 ][ 11 ]]
  [[ signed char*->unsigned long long ][ !!! *3* !!! ][ 55 ][ 11 ][ 11 ]]
  [[ signed char*->float ][ 51 ][ 82 ][ 33 ][ !!! *23* !!! ]]
  [[ signed char*->double ][ 50 ][ 77 ][ 30 ][ !!! *22* !!! ]]
  [[ signed char*->long double ][ 51 ][ 77 ][ 30 ][ !!! *24* !!! ]]
  [[ signed char*->array<char, 50> ][ !!! *<1* !!! ][ 55 ][ 12 ][ 9 ]]
  [[ signed char*->string ][ !!! *1* !!! ][ 54 ][ 11 ][ --- ]]
  [[ signed char*->container::string ][ !!! *1* !!! ][ 58 ][ 18 ][ --- ]]
  [[ iterator_range<char*>->char ][ !!! *<1* !!! ][ 51 ][ 6 ][ 6 ]]
  [[ iterator_range<char*>->signed char ][ !!! *<1* !!! ][ 46 ][ 5 ][ 7 ]]
  [[ iterator_range<char*>->unsigned char ][ !!! *<1* !!! ][ 49 ][ 5 ][ 11 ]]
  [[ iterator_range<char*>->int ][ !!! *3* !!! ][ 65 ][ 15 ][ 11 ]]
  [[ iterator_range<char*>->short ][ !!! *3* !!! ][ 58 ][ 14 ][ 11 ]]
  [[ iterator_range<char*>->long int ][ !!! *3* !!! ][ 60 ][ 14 ][ 12 ]]
  [[ iterator_range<char*>->long long ][ !!! *3* !!! ][ 57 ][ 16 ][ 11 ]]
  [[ iterator_range<char*>->unsigned int ][ !!! *2* !!! ][ 58 ][ 14 ][ 11 ]]
  [[ iterator_range<char*>->unsigned short ][ !!! *3* !!! ][ 60 ][ 14 ][ 12 ]]
  [[ iterator_range<char*>->unsigned long int ][ !!! *3* !!! ][ 58 ][ 14 ][ 11 ]]
  [[ iterator_range<char*>->unsigned long long ][ !!! *3* !!! ][ 59 ][ 14 ][ 11 ]]
  [[ iterator_range<char*>->float ][ 50 ][ 92 ][ 44 ][ !!! *23* !!! ]]
  [[ iterator_range<char*>->double ][ 48 ][ 87 ][ 38 ][ !!! *23* !!! ]]
  [[ iterator_range<char*>->long double ][ 51 ][ 93 ][ 47 ][ !!! *24* !!! ]]
  [[ iterator_range<char*>->array<char, 50> ][ !!! *<1* !!! ][ 65 ][ 17 ][ 9 ]]
  [[ iterator_range<char*>->string ][ !!! *1* !!! ][ 68 ][ 24 ][ --- ]]
  [[ iterator_range<char*>->container::string ][ !!! *1* !!! ][ 70 ][ 24 ][ --- ]]
  [[ std::string_view->char ][ 21 ][ 52 ][ !!! *4* !!! ][ 6 ]]
  [[ std::string_view->signed char ][ 21 ][ 51 ][ !!! *5* !!! ][ 7 ]]
  [[ std::string_view->unsigned char ][ 21 ][ 48 ][ !!! *4* !!! ][ 7 ]]
  [[ std::string_view->int ][ 25 ][ 57 ][ 11 ][ !!! *11* !!! ]]
  [[ std::string_view->short ][ 24 ][ 59 ][ 11 ][ !!! *11* !!! ]]
  [[ std::string_view->long int ][ 24 ][ 63 ][ 11 ][ !!! *11* !!! ]]
  [[ std::string_view->long long ][ 24 ][ 56 ][ 11 ][ !!! *11* !!! ]]
  [[ std::string_view->unsigned int ][ 25 ][ 54 ][ !!! *10* !!! ][ 11 ]]
  [[ std::string_view->unsigned short ][ 25 ][ 57 ][ !!! *10* !!! ][ 11 ]]
  [[ std::string_view->unsigned long int ][ 24 ][ 58 ][ 11 ][ !!! *11* !!! ]]
  [[ std::string_view->unsigned long long ][ 25 ][ 61 ][ 11 ][ !!! *11* !!! ]]
  [[ std::string_view->float ][ 77 ][ 84 ][ 35 ][ !!! *29* !!! ]]
  [[ std::string_view->double ][ 74 ][ 77 ][ 32 ][ !!! *23* !!! ]]
  [[ std::string_view->long double ][ 82 ][ 78 ][ 31 ][ !!! *24* !!! ]]
  [[ std::string_view->array<char, 50> ][ 22 ][ 57 ][ 10 ][ !!! *10* !!! ]]
  [[ std::string_view->string ][ 25 ][ 60 ][ !!! *12* !!! ][ --- ]]
  [[ std::string_view->container::string ][ 23 ][ 60 ][ !!! *14* !!! ][ --- ]]
  [[ array<char, 50>->char ][ !!! *<1* !!! ][ 47 ][ 5 ][ 6 ]]
  [[ array<char, 50>->signed char ][ !!! *<1* !!! ][ 48 ][ 5 ][ 7 ]]
  [[ array<char, 50>->unsigned char ][ !!! *<1* !!! ][ 47 ][ 5 ][ 7 ]]
  [[ array<char, 50>->int ][ !!! *3* !!! ][ 57 ][ 12 ][ 12 ]]
  [[ array<char, 50>->short ][ !!! *4* !!! ][ 56 ][ 11 ][ 11 ]]
  [[ array<char, 50>->long int ][ !!! *3* !!! ][ 55 ][ 11 ][ 11 ]]
  [[ array<char, 50>->long long ][ !!! *3* !!! ][ 54 ][ 11 ][ 11 ]]
  [[ array<char, 50>->unsigned int ][ !!! *3* !!! ][ 53 ][ 10 ][ 11 ]]
  [[ array<char, 50>->unsigned short ][ !!! *3* !!! ][ 58 ][ 10 ][ 11 ]]
  [[ array<char, 50>->unsigned long int ][ !!! *3* !!! ][ 54 ][ 11 ][ 11 ]]
  [[ array<char, 50>->unsigned long long ][ !!! *3* !!! ][ 54 ][ 11 ][ 11 ]]
  [[ array<char, 50>->float ][ 49 ][ 86 ][ 33 ][ !!! *22* !!! ]]
  [[ array<char, 50>->double ][ 46 ][ 79 ][ 29 ][ !!! *22* !!! ]]
  [[ array<char, 50>->long double ][ 51 ][ 77 ][ 38 ][ !!! *23* !!! ]]
  [[ array<char, 50>->array<char, 50> ][ !!! *<1* !!! ][ 54 ][ 10 ][ 9 ]]
  [[ array<char, 50>->string ][ !!! *1* !!! ][ 55 ][ 11 ][ --- ]]
  [[ array<char, 50>->container::string ][ !!! *1* !!! ][ 59 ][ 14 ][ --- ]]
  [[ int->int ][ !!! *<1* !!! ][ 57 ][ 13 ][ --- ]]
  [[ float->double ][ !!! *<1* !!! ][ 123 ][ 65 ][ --- ]]
  [[ char->signed char ][ !!! *<1* !!! ][ 47 ][ 5 ][ --- ]]
]
[endsect]

[section GNU C++ version 10.5.0]
[table:id Performance Table ( GNU C++ version 10.5.0)
[[From->To] [lexical_cast] [std::stringstream with construction] [std::stringstream without construction][scanf/printf]]
  [[ string->char ][ !!! *<1* !!! ][ 61 ][ 5 ][ 5 ]]
  [[ string->signed char ][ !!! *<1* !!! ][ 65 ][ 5 ][ 7 ]]
  [[ string->unsigned char ][ !!! *<1* !!! ][ 55 ][ 5 ][ 7 ]]
  [[ string->int ][ !!! *3* !!! ][ 64 ][ 11 ][ 10 ]]
  [[ string->short ][ !!! *3* !!! ][ 63 ][ 11 ][ 10 ]]
  [[ string->long int ][ !!! *4* !!! ][ 63 ][ 11 ][ 10 ]]
  [[ string->long long ][ !!! *3* !!! ][ 63 ][ 11 ][ 10 ]]
  [[ string->unsigned int ][ !!! *3* !!! ][ 63 ][ 10 ][ 10 ]]
  [[ string->unsigned short ][ !!! *3* !!! ][ 63 ][ 10 ][ 10 ]]
  [[ string->unsigned long int ][ !!! *3* !!! ][ 60 ][ 11 ][ 10 ]]
  [[ string->unsigned long long ][ !!! *3* !!! ][ 60 ][ 11 ][ 10 ]]
  [[ string->float ][ 52 ][ 89 ][ 34 ][ !!! *21* !!! ]]
  [[ string->double ][ 55 ][ 92 ][ 31 ][ !!! *28* !!! ]]
  [[ string->long double ][ 52 ][ 83 ][ !!! *31* !!! ][ 33 ]]
  [[ string->array<char, 50> ][ !!! *1* !!! ][ 153 ][ 25 ][ 11 ]]
  [[ string->string ][ !!! *1* !!! ][ 63 ][ 11 ][ --- ]]
  [[ string->container::string ][ !!! *1* !!! ][ 60 ][ 11 ][ --- ]]
  [[ string->char ][ !!! *<1* !!! ][ 59 ][ 10 ][ 7 ]]
  [[ string->signed char ][ !!! *1* !!! ][ 58 ][ 10 ][ 10 ]]
  [[ string->unsigned char ][ !!! *<1* !!! ][ 58 ][ 9 ][ 10 ]]
  [[ int->string ][ !!! *3* !!! ][ 66 ][ 13 ][ 10 ]]
  [[ short->string ][ !!! *3* !!! ][ 70 ][ 13 ][ 10 ]]
  [[ long int->string ][ !!! *3* !!! ][ 65 ][ 13 ][ 10 ]]
  [[ long long->string ][ !!! *4* !!! ][ 61 ][ 13 ][ 10 ]]
  [[ unsigned int->string ][ !!! *3* !!! ][ 96 ][ 31 ][ 24 ]]
  [[ unsigned short->string ][ !!! *8* !!! ][ 163 ][ 31 ][ 25 ]]
  [[ unsigned long int->string ][ !!! *8* !!! ][ 160 ][ 32 ][ 25 ]]
  [[ unsigned long long->string ][ !!! *9* !!! ][ 158 ][ 32 ][ 26 ]]
  [[ float->string ][ 63 ][ 259 ][ 107 ][ !!! *58* !!! ]]
  [[ double->string ][ 79 ][ 267 ][ 114 ][ !!! *57* !!! ]]
  [[ long double->string ][ 104 ][ 261 ][ 125 ][ !!! *63* !!! ]]
  [[ char*->char ][ !!! *<1* !!! ][ 140 ][ 13 ][ 13 ]]
  [[ char*->signed char ][ !!! *<1* !!! ][ 142 ][ 13 ][ 17 ]]
  [[ char*->unsigned char ][ !!! *<1* !!! ][ 139 ][ 13 ][ 16 ]]
  [[ char*->int ][ !!! *9* !!! ][ 162 ][ 30 ][ 26 ]]
  [[ char*->short ][ !!! *10* !!! ][ 153 ][ 29 ][ 26 ]]
  [[ char*->long int ][ !!! *13* !!! ][ 155 ][ 30 ][ 25 ]]
  [[ char*->long long ][ !!! *9* !!! ][ 159 ][ 29 ][ 26 ]]
  [[ char*->unsigned int ][ !!! *8* !!! ][ 147 ][ 26 ][ 25 ]]
  [[ char*->unsigned short ][ !!! *8* !!! ][ 156 ][ 29 ][ 27 ]]
  [[ char*->unsigned long int ][ !!! *9* !!! ][ 193 ][ 29 ][ 26 ]]
  [[ char*->unsigned long long ][ !!! *9* !!! ][ 155 ][ 33 ][ 29 ]]
  [[ char*->float ][ 137 ][ 215 ][ 78 ][ !!! *51* !!! ]]
  [[ char*->double ][ 147 ][ 247 ][ 111 ][ !!! *56* !!! ]]
  [[ char*->long double ][ 148 ][ 245 ][ 86 ][ !!! *65* !!! ]]
  [[ char*->array<char, 50> ][ !!! *1* !!! ][ 184 ][ 28 ][ 23 ]]
  [[ char*->string ][ !!! *3* !!! ][ 165 ][ 29 ][ --- ]]
  [[ char*->container::string ][ !!! *3* !!! ][ 168 ][ 34 ][ --- ]]
  [[ unsigned char*->char ][ !!! *<1* !!! ][ 155 ][ 15 ][ 14 ]]
  [[ unsigned char*->signed char ][ !!! *<1* !!! ][ 150 ][ 15 ][ 18 ]]
  [[ unsigned char*->unsigned char ][ !!! *<1* !!! ][ 153 ][ 13 ][ 17 ]]
  [[ unsigned char*->int ][ !!! *9* !!! ][ 175 ][ 31 ][ 26 ]]
  [[ unsigned char*->short ][ !!! *9* !!! ][ 172 ][ 33 ][ 29 ]]
  [[ unsigned char*->long int ][ 14 ][ 72 ][ 11 ][ !!! *10* !!! ]]
  [[ unsigned char*->long long ][ !!! *3* !!! ][ 62 ][ 12 ][ 10 ]]
  [[ unsigned char*->unsigned int ][ !!! *3* !!! ][ 68 ][ 10 ][ 17 ]]
  [[ unsigned char*->unsigned short ][ !!! *3* !!! ][ 71 ][ 11 ][ 10 ]]
  [[ unsigned char*->unsigned long int ][ !!! *3* !!! ][ 81 ][ 12 ][ 10 ]]
  [[ unsigned char*->unsigned long long ][ !!! *3* !!! ][ 58 ][ 11 ][ 10 ]]
  [[ unsigned char*->float ][ 52 ][ 100 ][ 37 ][ !!! *28* !!! ]]
  [[ unsigned char*->double ][ 56 ][ 97 ][ 33 ][ !!! *21* !!! ]]
  [[ unsigned char*->long double ][ 56 ][ 82 ][ 30 ][ !!! *23* !!! ]]
  [[ unsigned char*->array<char, 50> ][ !!! *<1* !!! ][ 58 ][ 10 ][ 8 ]]
  [[ unsigned char*->string ][ !!! *1* !!! ][ 61 ][ 11 ][ --- ]]
  [[ unsigned char*->container::string ][ !!! *1* !!! ][ 63 ][ 12 ][ --- ]]
  [[ signed char*->char ][ !!! *<1* !!! ][ 60 ][ 5 ][ 5 ]]
  [[ signed char*->signed char ][ !!! *<1* !!! ][ 58 ][ 6 ][ 7 ]]
  [[ signed char*->unsigned char ][ !!! *<1* !!! ][ 52 ][ 5 ][ 7 ]]
  [[ signed char*->int ][ !!! *3* !!! ][ 64 ][ 12 ][ 10 ]]
  [[ signed char*->short ][ !!! *4* !!! ][ 66 ][ 12 ][ 10 ]]
  [[ signed char*->long int ][ !!! *4* !!! ][ 65 ][ 12 ][ 13 ]]
  [[ signed char*->long long ][ !!! *6* !!! ][ 64 ][ 12 ][ 10 ]]
  [[ signed char*->unsigned int ][ !!! *3* !!! ][ 60 ][ 11 ][ 10 ]]
  [[ signed char*->unsigned short ][ !!! *3* !!! ][ 60 ][ 11 ][ 10 ]]
  [[ signed char*->unsigned long int ][ !!! *4* !!! ][ 60 ][ 11 ][ 10 ]]
  [[ signed char*->unsigned long long ][ !!! *3* !!! ][ 64 ][ 11 ][ 10 ]]
  [[ signed char*->float ][ 52 ][ 86 ][ 33 ][ !!! *21* !!! ]]
  [[ signed char*->double ][ 50 ][ 88 ][ 32 ][ !!! *21* !!! ]]
  [[ signed char*->long double ][ 51 ][ 87 ][ 30 ][ !!! *23* !!! ]]
  [[ signed char*->array<char, 50> ][ !!! *<1* !!! ][ 63 ][ 10 ][ 8 ]]
  [[ signed char*->string ][ !!! *1* !!! ][ 62 ][ 11 ][ --- ]]
  [[ signed char*->container::string ][ !!! *1* !!! ][ 62 ][ 12 ][ --- ]]
  [[ iterator_range<char*>->char ][ !!! *<1* !!! ][ 55 ][ 5 ][ 5 ]]
  [[ iterator_range<char*>->signed char ][ !!! *<1* !!! ][ 60 ][ 5 ][ 7 ]]
  [[ iterator_range<char*>->unsigned char ][ !!! *<1* !!! ][ 61 ][ 6 ][ 7 ]]
  [[ iterator_range<char*>->int ][ !!! *3* !!! ][ 83 ][ 18 ][ 12 ]]
  [[ iterator_range<char*>->short ][ !!! *4* !!! ][ 74 ][ 17 ][ 12 ]]
  [[ iterator_range<char*>->long int ][ !!! *6* !!! ][ 77 ][ 17 ][ 12 ]]
  [[ iterator_range<char*>->long long ][ !!! *3* !!! ][ 74 ][ 18 ][ 12 ]]
  [[ iterator_range<char*>->unsigned int ][ !!! *3* !!! ][ 71 ][ 18 ][ 14 ]]
  [[ iterator_range<char*>->unsigned short ][ !!! *3* !!! ][ 109 ][ 38 ][ 26 ]]
  [[ iterator_range<char*>->unsigned long int ][ !!! *8* !!! ][ 176 ][ 39 ][ 27 ]]
  [[ iterator_range<char*>->unsigned long long ][ !!! *8* !!! ][ 227 ][ 46 ][ 42 ]]
  [[ iterator_range<char*>->float ][ 196 ][ 303 ][ 126 ][ !!! *58* !!! ]]
  [[ iterator_range<char*>->double ][ 174 ][ 345 ][ 136 ][ !!! *73* !!! ]]
  [[ iterator_range<char*>->long double ][ 202 ][ 321 ][ 106 ][ !!! *64* !!! ]]
  [[ iterator_range<char*>->array<char, 50> ][ !!! *1* !!! ][ 198 ][ 58 ][ 27 ]]
  [[ iterator_range<char*>->string ][ !!! *3* !!! ][ 213 ][ 54 ][ --- ]]
  [[ iterator_range<char*>->container::string ][ !!! *2* !!! ][ 206 ][ 52 ][ --- ]]
  [[ std::string_view->char ][ 56 ][ 132 ][ 13 ][ !!! *13* !!! ]]
  [[ std::string_view->signed char ][ 54 ][ 150 ][ !!! *14* !!! ][ 21 ]]
  [[ std::string_view->unsigned char ][ 59 ][ 159 ][ !!! *14* !!! ][ 19 ]]
  [[ std::string_view->int ][ 81 ][ 179 ][ 32 ][ !!! *29* !!! ]]
  [[ std::string_view->short ][ 81 ][ 201 ][ !!! *35* !!! ][ 39 ]]
  [[ std::string_view->long int ][ 86 ][ 312 ][ 74 ][ !!! *67* !!! ]]
  [[ std::string_view->long long ][ 91 ][ 259 ][ 34 ][ !!! *28* !!! ]]
  [[ std::string_view->unsigned int ][ 81 ][ 178 ][ 28 ][ !!! *26* !!! ]]
  [[ std::string_view->unsigned short ][ 71 ][ 186 ][ 48 ][ !!! *28* !!! ]]
  [[ std::string_view->unsigned long int ][ 74 ][ 197 ][ 44 ][ !!! *33* !!! ]]
  [[ std::string_view->unsigned long long ][ 91 ][ 200 ][ !!! *38* !!! ][ 39 ]]
  [[ std::string_view->float ][ 257 ][ 327 ][ 135 ][ !!! *97* !!! ]]
  [[ std::string_view->double ][ 294 ][ 251 ][ 80 ][ !!! *53* !!! ]]
  [[ std::string_view->long double ][ 204 ][ 258 ][ 101 ][ !!! *64* !!! ]]
  [[ std::string_view->array<char, 50> ][ 62 ][ 174 ][ 26 ][ !!! *20* !!! ]]
  [[ std::string_view->string ][ 57 ][ 161 ][ !!! *27* !!! ][ --- ]]
  [[ std::string_view->container::string ][ 54 ][ 156 ][ !!! *29* !!! ][ --- ]]
  [[ array<char, 50>->char ][ !!! *<1* !!! ][ 136 ][ 14 ][ 14 ]]
  [[ array<char, 50>->signed char ][ !!! *<1* !!! ][ 171 ][ 16 ][ 19 ]]
  [[ array<char, 50>->unsigned char ][ !!! *<1* !!! ][ 153 ][ 14 ][ 17 ]]
  [[ array<char, 50>->int ][ !!! *9* !!! ][ 164 ][ 30 ][ 27 ]]
  [[ array<char, 50>->short ][ !!! *10* !!! ][ 157 ][ 30 ][ 26 ]]
  [[ array<char, 50>->long int ][ !!! *13* !!! ][ 156 ][ 29 ][ 25 ]]
  [[ array<char, 50>->long long ][ !!! *9* !!! ][ 160 ][ 29 ][ 25 ]]
  [[ array<char, 50>->unsigned int ][ !!! *8* !!! ][ 155 ][ 26 ][ 25 ]]
  [[ array<char, 50>->unsigned short ][ !!! *8* !!! ][ 88 ][ 10 ][ 10 ]]
  [[ array<char, 50>->unsigned long int ][ !!! *3* !!! ][ 60 ][ 11 ][ 10 ]]
  [[ array<char, 50>->unsigned long long ][ !!! *3* !!! ][ 61 ][ 11 ][ 10 ]]
  [[ array<char, 50>->float ][ 53 ][ 100 ][ 40 ][ !!! *22* !!! ]]
  [[ array<char, 50>->double ][ 64 ][ 97 ][ 34 ][ !!! *22* !!! ]]
  [[ array<char, 50>->long double ][ 56 ][ 90 ][ 34 ][ !!! *24* !!! ]]
  [[ array<char, 50>->array<char, 50> ][ !!! *1* !!! ][ 60 ][ 10 ][ 8 ]]
  [[ array<char, 50>->string ][ !!! *1* !!! ][ 64 ][ 12 ][ --- ]]
  [[ array<char, 50>->container::string ][ !!! *1* !!! ][ 66 ][ 12 ][ --- ]]
  [[ int->int ][ !!! *<1* !!! ][ 69 ][ 15 ][ --- ]]
  [[ float->double ][ !!! *<1* !!! ][ 139 ][ 78 ][ --- ]]
  [[ char->signed char ][ !!! *<1* !!! ][ 57 ][ 5 ][ --- ]]
]
[endsect]






[/ END of section, generated by performance measuring program ]
[endsect]

